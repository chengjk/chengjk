---
title: 1000个苹果10个箱子
date: 2016-11-30 12:54:35
tags: fun
mathjax: true
---
## 题目
1000个苹果放入10个箱子。客户如果要获得1~1000个苹果中的任意个数，都可以整箱搬，而不用拆开箱子。问是否有这样的装箱方法？


## 第一个答案
第一反应就是二进制，于是有（$2^0$~$2^9$ ）等比数列的思路。但只有1000个苹果，因此最后一箱应该是489（$2^9$-13）。

```shell
(1,2,4,8,16,32,64,128,256,489)
```

因为最高位不是$2^n$，因此在这里大于512的数字就不能用二进制表示了。那这部分数字怎么获得呢？

问题的最终结果是把1000个苹果分为两部分，目标x与（1000-x），也就是说获得$500+n$和获得$500-n$其实是一个问题。前9个箱子可以表示1-511的任何数字，512~1000又可以表示为一个小于500的数字的补数，问题解决。表示为：
   
$ 
f(n) =
\begin{cases}
前9个箱子的二进制表示  & \text{ $n$ <= 511} \\
1000-前9个箱子的二进制表示 & \text{ 1000>= $n$ > 511}
\end{cases}
$

## 问题继续
这个问题我们已经找到了一个解，那么还有其他解吗，怎么求解？

当然最粗暴的方法就是遍历，只要满足条件：

1. 集合长度等于10
2. 集合元素之和等于1000
3. 能组合出1~1000的所有数字
    
好处就是能求出全部解法，坏处就是慢且耗费资源。

### 分析
如果有1023个苹果，那就完美了，用2进制表示。就只有一个解：
```
(1,2,4,8,16,32,64,128,256,512)
```

如果是1022个呢？少了1个。那么正确的解一定是$(2^0-2^9)$ 集合中的某个元素减1。经过简单人工验算，少的这一个一定在最后一个元素，也就是从512变成了511。
```
(1,2,4,8,16,32,64,128,256,511)
```
如果是1021呢？少了2个。有两个解：
```
(1,2,4,8,16,32,64,128,256,510)
(1,2,4,8,16,32,64,128,255,511)
```

这时就会发现原来从1000个数字里找到满足条件的10 个数字的问题转化成了将23个名额分配到以$(2^0-2^9)$ 为基础的集合中。每个正确的解都属于这些分配组合的集合。这是必要条件。

$
1023=>(1,2,4,8,16,32,64,128,256,512)
$
$
1000=>(1,2,4,8,16,32,64,128,256,512)-23
$

> 1.分给所有元素的值之和等于23
2.分给某个元素的值不大于23


### 继续观察
如果给基础集合的第三位(4)减去1,那么前三位表示的数字范围从1-7变成了1-6,如果第四位(8)不变，那么7这个数子就无法表示了；要表示7就必须给第四位(8)减1，同理，后边的元素都得至少减1。
当第三（4）第四（8）位都减1之后，前四位的表示范围从1-16变成了1-14.也就是说第五位至少得减去2。有趣的结果出来了

> 3.分给某个元素的值要大于等于分给前边所有元素之和。

问题转化成了把23按这个规则分配。正确答案一定在这里头。目前还是必要条件。


## 更多的答案
用程序实现，思路如下
1. 把数字23按上述规则拆分。得到一系列拆分结果集合。
2. 把每一个拆分集合与基础集合组合。得到全部结果集合。
3. 验证全部结果集合，是否可以获得1-1000的所有数字。

```java

/**
 * Created by jacky.cheng on 2016/6/16.
 */
public class AppleTest {
    private static List<List<Integer>> result = new ArrayList<>();
    private static Integer[] baseLine = {512, 256, 128, 64, 32, 16, 8, 4, 2, 1};

    public static void main(String[] args) {
        generate();
    }

    /**
     * 计算全部解
     */
    private static void generate() {
        Integer origin = 23;
        List<Integer> seed = new ArrayList<>();
        seed.add(origin);
        result.add(seed);
        recurChildren(seed);
        System.out.println("----------共有" + result.size() + "组结果--------");
        //分配结果与基础集合组合
        result = result.stream().map(r -> {
            List<Integer> a = new ArrayList<>();
            for (int i = 0; i < 10; i++) {
                a.add(i < r.size() ? (baseLine[i] - r.get(i)) : baseLine[i]);
            }
            validate(a);
            return a;
        }).collect(Collectors.toList());
        System.out.println("-------------------------------------------------");
    }

    /**
     * 递归算出所有的分配方式
     *
     * @param o
     */
    private static void recurChildren(List<Integer> o) {
        Integer last = o.get(o.size() - 1);
        if (last > 1) {
            List<Integer> temp;
            Integer i = 0;
            while (--last >= ++i) {
                List<Integer> head = new ArrayList<>();
                for (int m = 0; m < o.size() - 1; m++) {
                    head.add(o.get(m));
                }
                temp = new ArrayList<>();
                temp.addAll(head);
                temp.add(last);
                temp.add(i);
                result.add(temp);
                recurChildren(temp);
            }
        }
    }

    /**
     * 验证一个结果 1-1000。
     *
     * @param p
     * @return
     */
    private static boolean validate(List<Integer> p) {
        for (int i = 1000; i > 0; i--) {
            if (!validateOne(i, p)) {
                System.out.println("Failed! " + i + " for:" + p.toString());
                return false;
            }
        }
        System.out.println(p.toString() + " ok");
        return true;
    }

    /**
     * 验证一个结果的一个值。
     *
     * @param p
     * @return
     */
    private static boolean validateOne(int i, List<Integer> p) {
        int r = 0;
        for (Integer b : p) {
            if (r + b <= i) r = r + b;
        }
        return r == i;
    }
}
```

运行程序得到了74 组解，并且每一组都通过了验证。

``` bash
[489, 256, 128, 64, 32, 16, 8, 4, 2, 1] ok
[490, 255, 128, 64, 32, 16, 8, 4, 2, 1] ok
[491, 254, 128, 64, 32, 16, 8, 4, 2, 1] ok
[491, 255, 127, 64, 32, 16, 8, 4, 2, 1] ok
[492, 253, 128, 64, 32, 16, 8, 4, 2, 1] ok
[492, 254, 127, 64, 32, 16, 8, 4, 2, 1] ok
[493, 252, 128, 64, 32, 16, 8, 4, 2, 1] ok
[493, 253, 127, 64, 32, 16, 8, 4, 2, 1] ok
[493, 254, 126, 64, 32, 16, 8, 4, 2, 1] ok
[493, 254, 127, 63, 32, 16, 8, 4, 2, 1] ok
[494, 251, 128, 64, 32, 16, 8, 4, 2, 1] ok
[494, 252, 127, 64, 32, 16, 8, 4, 2, 1] ok
[494, 253, 126, 64, 32, 16, 8, 4, 2, 1] ok
[494, 253, 127, 63, 32, 16, 8, 4, 2, 1] ok
[495, 250, 128, 64, 32, 16, 8, 4, 2, 1] ok
[495, 251, 127, 64, 32, 16, 8, 4, 2, 1] ok
[495, 252, 126, 64, 32, 16, 8, 4, 2, 1] ok
[495, 252, 127, 63, 32, 16, 8, 4, 2, 1] ok
[495, 253, 125, 64, 32, 16, 8, 4, 2, 1] ok
[495, 253, 126, 63, 32, 16, 8, 4, 2, 1] ok
[496, 249, 128, 64, 32, 16, 8, 4, 2, 1] ok
[496, 250, 127, 64, 32, 16, 8, 4, 2, 1] ok
[496, 251, 126, 64, 32, 16, 8, 4, 2, 1] ok
[496, 251, 127, 63, 32, 16, 8, 4, 2, 1] ok
[496, 252, 125, 64, 32, 16, 8, 4, 2, 1] ok
[496, 252, 126, 63, 32, 16, 8, 4, 2, 1] ok
[497, 248, 128, 64, 32, 16, 8, 4, 2, 1] ok
[497, 249, 127, 64, 32, 16, 8, 4, 2, 1] ok
[497, 250, 126, 64, 32, 16, 8, 4, 2, 1] ok
[497, 250, 127, 63, 32, 16, 8, 4, 2, 1] ok
[497, 251, 125, 64, 32, 16, 8, 4, 2, 1] ok
[497, 251, 126, 63, 32, 16, 8, 4, 2, 1] ok
[497, 252, 124, 64, 32, 16, 8, 4, 2, 1] ok
[497, 252, 125, 63, 32, 16, 8, 4, 2, 1] ok
[497, 252, 126, 62, 32, 16, 8, 4, 2, 1] ok
[497, 252, 126, 63, 31, 16, 8, 4, 2, 1] ok
[498, 247, 128, 64, 32, 16, 8, 4, 2, 1] ok
[498, 248, 127, 64, 32, 16, 8, 4, 2, 1] ok
[498, 249, 126, 64, 32, 16, 8, 4, 2, 1] ok
[498, 249, 127, 63, 32, 16, 8, 4, 2, 1] ok
[498, 250, 125, 64, 32, 16, 8, 4, 2, 1] ok
[498, 250, 126, 63, 32, 16, 8, 4, 2, 1] ok
[498, 251, 124, 64, 32, 16, 8, 4, 2, 1] ok
[498, 251, 125, 63, 32, 16, 8, 4, 2, 1] ok
[498, 251, 126, 62, 32, 16, 8, 4, 2, 1] ok
[498, 251, 126, 63, 31, 16, 8, 4, 2, 1] ok
[499, 246, 128, 64, 32, 16, 8, 4, 2, 1] ok
[499, 247, 127, 64, 32, 16, 8, 4, 2, 1] ok
[499, 248, 126, 64, 32, 16, 8, 4, 2, 1] ok
[499, 248, 127, 63, 32, 16, 8, 4, 2, 1] ok
[499, 249, 125, 64, 32, 16, 8, 4, 2, 1] ok
[499, 249, 126, 63, 32, 16, 8, 4, 2, 1] ok
[499, 250, 124, 64, 32, 16, 8, 4, 2, 1] ok
[499, 250, 125, 63, 32, 16, 8, 4, 2, 1] ok
[499, 250, 126, 62, 32, 16, 8, 4, 2, 1] ok
[499, 250, 126, 63, 31, 16, 8, 4, 2, 1] ok
[499, 251, 123, 64, 32, 16, 8, 4, 2, 1] ok
[499, 251, 124, 63, 32, 16, 8, 4, 2, 1] ok
[499, 251, 125, 62, 32, 16, 8, 4, 2, 1] ok
[499, 251, 125, 63, 31, 16, 8, 4, 2, 1] ok
[500, 245, 128, 64, 32, 16, 8, 4, 2, 1] ok
[500, 246, 127, 64, 32, 16, 8, 4, 2, 1] ok
[500, 247, 126, 64, 32, 16, 8, 4, 2, 1] ok
[500, 247, 127, 63, 32, 16, 8, 4, 2, 1] ok
[500, 248, 125, 64, 32, 16, 8, 4, 2, 1] ok
[500, 248, 126, 63, 32, 16, 8, 4, 2, 1] ok
[500, 249, 124, 64, 32, 16, 8, 4, 2, 1] ok
[500, 249, 125, 63, 32, 16, 8, 4, 2, 1] ok
[500, 249, 126, 62, 32, 16, 8, 4, 2, 1] ok
[500, 249, 126, 63, 31, 16, 8, 4, 2, 1] ok
[500, 250, 123, 64, 32, 16, 8, 4, 2, 1] ok
[500, 250, 124, 63, 32, 16, 8, 4, 2, 1] ok
[500, 250, 125, 62, 32, 16, 8, 4, 2, 1] ok
[500, 250, 125, 63, 31, 16, 8, 4, 2, 1] ok
```

## 验证
按条件遍历搜寻全部结果，和上述结果比对。
需要满足的条件：
1. 集合长度等于10
2. 集合元素之和等于1000
3. 能组合出1~1000的所有数字

- 直接遍历，每个元素的取值范围是：

```
（m~n]
(1,2,2~4,4~8,8~16,16~32,32~64,64~128,128~256,256~512)
```

- 结合分析结论1，每个元素都大于前一个，且最多比基础少23。于是每个元素的取值范围是：

```
（m~n]
(1,2,2~4,4~8,8~16,16~32,41~64,105~128,233~256,489~512)
```
- 结合分析结论1和结论3，每个元素的取值范围是：

```
[m~n]
(1,2,4,8,16,31~32,62~64,123~128,245~256,489~512)
又因为必须把23个分完，最高位的取值范围变成了489~500
```
    
Java实现：
为了方便计算，我们把基础集合倒序排列。
```java
public class AppleTest2 {
    public static void main(String[] args) {
        eval();
    }
    static void eval(){
        for (int box6 = 31; box6 <= 32; box6++) {
            for (int box7 = 62; box7 <= 64; box7++) {
                for (int box8 = 123; box8 <=128; box8++) {
                    for (int box9 = 245; box9 <=256; box9++) {
                        for (int box10 = 489; box10 <= 500; box10++) {
                            Integer[] vars = new Integer[10];
                            vars[0] = 1;
                            vars[1] = 2;
                            vars[2] = 4;
                            vars[3] = 8;
                            vars[4] = 16;
                            vars[5] = box6;
                            vars[6] = box7;
                            vars[7] = box8;
                            vars[8] = box9;
                            vars[9] = box10;
                            if(addAllEqual1000(vars)){
                                boolean flag = true;
                                for (int i = 1; i <= 1000; i++) {
                                    flag = canBuild(i, vars);
                                    if (!flag) break;
                                }
                                if (flag) System.out.println(ArrayUtils.toString(vars));
                            }
                        }
                    }
                }
            }
        }
    }
    private static boolean canBuild(int value,Integer [] vars) {
        Boolean[] has = {true,true,true,true,true,true,true,true,true,true};
        int len = vars.length;
        for (int i = len - 1; i >= 0; i--) {
            if (value >= vars[i] && has[i]) {
                value -= vars[i];
                has[i] = false;
                if (value == 0) return true;
            }
        }
        return false;
    }

    static boolean addAllEqual1000(Integer [] vars){
        int sum=0;
        for (Integer var : vars) {
            sum+=var;
        }
        return sum==1000;
    }
}
```

运行程序同样得到了74 组解，且都通过了验证。

## 问题与总结
对于一个相对复杂的问题，分析总结还是很重要的。如上述过程，即使用粗暴的遍历，分析也可以大幅缩小答案的取值范围：直接遍历循环次数是68719476736（2*4*8*16*32*64*128*256），分析后遍历循环次数是4032（2*2*3*4*7*12）足足降低了7个数量级。

以上证明都是依据与观察总结，虽然得到了全部结果，总觉不完美。不知有没有严格证明过程。
